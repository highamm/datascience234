---
title: "Introduction to `knn` Code"
author: "Matt Higham"
output: 
  rmdformats::readthedown:
    code_folding: show
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
  collapse = TRUE, fig.height = 3)
```

The purpose of this .Rmd file is to make sure that everyone can install the `class` library and use the `knn` function. More explanation of a training sample and holdout sample will be provided along with the directions for your final project.

```{r}
library(tidyverse)
set.seed(11232020) ## run this line so that you get the same 
## results as I do!
pokemon <- read_csv("pokemon_full.csv") %>% filter(Type %in% c("Steel", "Dark", "Fire", "Ice")) 

## scale the quantitative predictors
pokemon_scaled <- pokemon %>%
    mutate(across(where(is.numeric), ~ (.x - min(.x)) /
                                 (max(.x) - min(.x)))) 

ntrain <- 70
indx <- sample(1:nrow(pokemon_scaled), size = ntrain, replace = FALSE)

## define a sample to "train" our knn model on
train_sample <- pokemon_scaled %>%
  slice(indx)

## use the rest of the data to "test" our knn model on to see 
## how well it's doing
holdout_sample <- pokemon_scaled %>%
  slice(-indx)
```

```{r}
## install.packages("class")
library(class)

## create a data frame that only has the predictors
## that we will use
train_small <- train_sample %>% select(HP, Attack, Defense, Speed)
holdout_small <- holdout_sample %>% select(HP, Attack, Defense, Speed)

## put our response variable into a vector
train_cat <- train_sample$Type
holdout_cat <- holdout_sample$Type

## fit the knn model with 9 nearest neighbors
knn_mod <- knn(train = train_small, test = holdout_small,
               cl = train_cat, k = 9)

table(knn_mod, holdout_cat) 

library(tidyverse)
## get the entire data set in scaled form, and select only
## the predictors we decided to use

pokemon_small <- pokemon_scaled %>% select(HP, Attack, Defense, Speed)
## put our response variable into a vector
pokemon_cat <- pokemon_scaled$Type

pokemon_new <- read_csv("pokemon_full.csv") %>% filter(Type %in% c("Grass")) %>% mutate(across(where(is.numeric), ~ (.x - min(.x)) /
                                 (max(.x) - min(.x))))
pokemon_newcat <- pokemon_new$Type


pokemon_new_predsonly <- pokemon_new %>% select(HP, Attack, Defense, Speed)

## fit the model using all available observations
knn_mod <- knn(train = pokemon_small, test = pokemon_new_predsonly,
               cl = pokemon_cat, k = 9)
knn_mod
```

The above table tells us that there were 3 pokemon that were Fire type that our knn model incorrectly classified as Dark. There were 6 pokemon that were Dark type that our knn model incorrectly classified as Fire. There were 13 Fire type pokemon that our knn model correctly classified as Fire type pokemon. In other words, correct predictions appear on the diagonal, while incorrect predictions appear on the off-diagonal.

Again, the purpose of this document is just to make sure that you can install the appropriate package and use the `knn` function. More details about what the above code is doing will be provided when the full project instructions are given.